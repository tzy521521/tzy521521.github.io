<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DaoVoice-Hexo博客添加在线联系功能]]></title>
    <url>%2F2019%2F09%2F02%2FDaoVoice%2F</url>
    <content type="text"><![CDATA[Hexo博客如何添加在线联系功能呢?DaoVoice是一个绝佳的客户沟通工具。 最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示: 也可以参考EZLippi的博客 注册DaoVoice首先到DaoVoice官网上注册一个账号,注册完成后会得到一个app_id，获取app_id的步骤如下图所示: 更改主题配置文件以next主题(版本是7.3.0)为例,在/themes/next/layout/_third-party/chat下添加daovoice.swig文件，代码如下： 123456789&#123;% if theme.daovoice.enable %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i["DaoVoiceObject"]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)&#125;)(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice") daovoice('init', &#123; app_id: "&#123;&#123;theme.daovoice.app_id&#125;&#125;" &#125;); daovoice('update'); &lt;/script&gt;&#123;% endif %&#125; 更改/themes/next/layout/_third-party/chat/index.swig中的代码： 123&#123;% include 'chatra.swig' %&#125;&#123;% include 'tidio.swig' %&#125;&#123;% include 'daovoice.swig' %&#125; 接着打开主题配置文件_config.yml，添加如下代码： 1234# DaoVoicedaovoice: enable: true app_id: #这里输入前面获取的app_id 修改完善需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置: 最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Next_Note]]></title>
    <url>%2F2019%2F08%2F30%2FNext-Note%2F</url>
    <content type="text"><![CDATA[Primary HeaderWelcome to Hexo!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Next_Button]]></title>
    <url>%2F2019%2F08%2F30%2FNext-Button%2F</url>
    <content type="text"><![CDATA[Text]]></content>
  </entry>
  <entry>
    <title><![CDATA[Logback配置详解]]></title>
    <url>%2F2019%2F08%2F28%2FLogback%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[logback.xml常用配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!-- &lt;configuration&gt;：根节点，包含下面3个属性 scan： 设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true scanPeriod: 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 debug: 设置为true时，将打印出logback内部日志信息，实时查看logback运行状态，默认值为false。 --&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- &lt;contextName&gt;：用来设置logger上下文名称，每个logger都关联到logger上下文，默认上下文名称为default。 使用&lt;contextName&gt;设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。 --&gt; &lt;contextName&gt;default&lt;/contextName&gt; &lt;!-- &lt;timestamp&gt;：获取时间戳字符串，他有两个属性 key: 标识此&lt;timestamp&gt; 的名字； datePattern: 设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循java.text.SimpleDateFormat的格式。 --&gt; &lt;timestamp key="bySecond" datePattern="yyyyMMdd'T'HHmmss"/&gt; &lt;!-- &lt;property&gt; ： 用来定义变量值，通过&lt;property&gt;定义的值会被插入到logger上下文中，可以使“$&#123;&#125;”来使用变量。 --&gt; &lt;property name="logPath" value="d:/test_log" /&gt; &lt;property name="maxHistory" value="30"/&gt; &lt;!-- &lt;appender&gt;： 负责写日志的组件，它有两个必要属性 name指定appender名称，class指定appender的全限定名配置项。 通过此节点配置日志输出位置（控制台、文件、数据库）、输出格式等 --&gt; &lt;!-- ConsoleAppender 输出到控制台。 --&gt; &lt;appender name="consoleLog" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- &lt;layout&gt;或者&lt;encoder&gt;对日志进行格式化 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger -%msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;!-- &lt;target&gt;：字符串System.out(默认)或者System.err --&gt; &lt;/appender&gt; &lt;!-- RollingFileAppender 输出到文件。滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="fileInfoLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- &lt;encoder&gt; 对记录事件进行格式化。负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。 PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个&lt;pattern&gt;节点，用来设置日志的输入格式。 --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- &lt;file&gt;：可有可无。被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 --&gt; &lt;!--&lt;file&gt;$&#123;logPath&#125;/info/tests.log&lt;/file&gt;--&gt; &lt;!-- &lt;append&gt;：true，日志被追加到文件结尾；false，清空现存文件。默认是true。 --&gt; &lt;apppend&gt;true&lt;/apppend&gt; &lt;!-- &lt;rollingPolicy&gt; 滚动策略，决定RollingFileAppender的行为，涉及文件移动和重命名 TimeBasedRollingPolicy，最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- &lt;fileNamePattern&gt;：必要节点，包含文件名及“%d”转换符。 “%d”可以包含一个java.text.SimpleDateFormat指定的时间格式，如：%d&#123;yyyy-MM&#125;。如果直接使用 %d，默认格式是 yyyy-MM-dd。 RollingFileAppender的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置。 当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。 --&gt; &lt;fileNamePattern&gt;$&#123;logPath&#125;/info/%d.log&lt;/fileNamePattern&gt; &lt;!-- &lt;maxHistory&gt; 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;!-- &lt;triggeringPolicy&gt;告知 RollingFileAppender 何时激活滚动。 SizeBasedTriggeringPolicy 查看当前活动文件的大小，如果超过指定大小会告知 RollingFileAppender 触发当前活动文件滚动 --&gt; &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt; &lt;!-- &lt;maxFileSize&gt;活动文件的大小，默认值是10MB --&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;!-- &lt;prudent&gt;：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 --&gt; &lt;prudent&gt;true&lt;/prudent&gt; &lt;/triggeringPolicy&gt; &lt;!-- FixedWindowRollingPolicy，根据固定窗口算法重命名文件的滚动策略。 这个设置的有问题。。。。。。。。。 按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。 该模式下&lt;fileNamePattern&gt;必须包含“%i”,假设最小值和最大值分别为1和3，命名模式为 mylog%i.log，会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者mylog%i.log.zip &lt;rollingPolicy class="ch.qos.logback.core.rolling.FixedWindowRollingPolicy"&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;fileNamePattern&gt;$&#123;logPath&#125;/info/%d%i.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; --&gt; &lt;/appender&gt; &lt;appender name="fileErrorLog" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 只记录ERROR级别日志，添加范围过滤，可以将该类型的日志特殊记录到某个位置 --&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;logPath&#125;/error/%d.log&lt;/fileNamePattern&gt; &lt;!-- 日志最大的历史 30天 --&gt; &lt;maxHistory&gt;$&#123;maxHistory&#125;&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- &lt;logger&gt; 设置某一个包或具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。 name: 用来指定受此&lt;loger&gt;约束的某一个包或者具体的某一个类。 level: 用来设置打印级别，大小写无关：ALL，TRACE, DEBUG, INFO, WARN, ERROR, OFF（级别从小到大）。 还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前loger将会继承上级的级别。 addtivity: 是否向上级&lt;loger&gt;传递打印信息。默认是true。 appender-ref 零个或多个，标识这个appender将会添加到这个loger。 --&gt; &lt;!-- &lt;root&gt; 也是&lt;logger&gt;元素，但是它是根&lt;logger&gt;，是所有&lt;logger&gt;的上级。只有一个level属性，因为name已经被命名为"root",且已经是最上级了。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="consoleLog" /&gt; &lt;appender-ref ref="fileInfoLog" /&gt; &lt;appender-ref ref="fileErrorLog" /&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis_Generator配置详解]]></title>
    <url>%2F2019%2F06%2F27%2FMyBatis-Generator%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[XML配置详解 在MBG中，最主要也最重要的就是XML配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" &gt;&lt;generatorConfiguration&gt; &lt;!-- &lt;generatorConfiguration&gt;(有严格的配置顺序) 下可以配置3种子元素&lt;properties&gt;、&lt;classPathEntry&gt; 和&lt;context&gt; (特别注意: 该配置文件只能放在classpath目录下，放在classpath下的任何包中都不可以。) --&gt; &lt;!-- &lt;properties&gt; 可选，最多配置1个 该元素用于指定一个需要在配置中解析使用的外部属性文件。配置中的任何属性将接受$&#123;property&#125;这种形式的属性。从指定的属性文件中搜索匹配的值，配置的值将会被替换。属性文件时普通的Java属性文件的格式。 该元素有2个必选属性(但是只能选择一个)： resource：属性文件的全限定名称。当指定了resource属性，将会从classpath下面搜索属性文件。当指定为com/myproject/generatorConfig.properties时，它必须存在com.myproject 包下面。 url： 属性文件的URL值。这可以用于指定一个属性文件在文件系统上的特定位置，例如 file:///C:/myfolder/generatorConfig.properties。 --&gt; &lt;properties resource="properties/jdbc.properties"/&gt; &lt;!-- &lt;classPathEntry&gt; 可选，可配置多个(Maven项目中不建议使用,Maven项目中在mybatis-generator-maven-plugin中添加依赖) 该元素用于将MBG运行时需要的jar包(或者zip格式)添加到classpath下。MBG在以下情况下从这些路径中加载类： 当为映射的数据库加载JDBC驱动时 当加载&lt;JavaModelGenerator&gt;中的根类以便检查重写的方法时 该元素有1个必选元素： location：要添加到classpath中的JAR/ZIP文件的完整路径名称或目录。 &lt;classPathEntry location="E:\mysql\mysql-connector-java-5.1.29.jar"/&gt; --&gt; &lt;!-- &lt;context&gt; 必选，最少配置一个 该元素用于指定生成一组对象的环境。子元素用于指定要连接到的数据库、要生成模型的类型和要处理的数据库中的表。多个&lt;context&gt;元素可以在&lt;generatorConfiguration&gt;元素中列出来，这样可以在同一个MBG中从不同的数据库或者使用不同的生成生成器参数生成对象。 该元素有1个必选属性： id： 用来唯一确定一个&lt;context&gt;元素。该值将用于某些错误的信息。(注意： 运行MBG的时候还可以指定要运行的&lt;context&gt;)。 该元素有3个可选属性： defaultModelType： 这个属性用来设置生成模型类型的默认值。模型类型定义了MBG如何生成领域类。对某些模型类型，MBG会给每一个表生成一个单独的领域类。对另外一些模型类型，MBG会根据表结构生成不同的类。这个属性有以下可选值： conditional： 默认值。这个模型和hierarchical模型类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。因此,如果一个表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。 flat： 该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。 hierarchical： 如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有BLOB字段，则还会为表生成一个包含所有BLOB字段的单独的实体类，然后为所有其他的字段生成一个单独的实体类。MBG会在所有生成的实体类之间维护一个继承关系(注：BLOB类 继承 其他字段类 继承 主键类)。 targetRuntime： 此属性用于指定生成的代码的运行时环境（~java模型生成器~&lt;javaModelGenerator&gt;）。该属性支持以下可选值： MyBatis3： 默认值。使用这值的时候，MBG生成的对象会生成兼容MyBatis 3.0或更高版本，兼容JSE5.0或更高版本的对象（例如，Java模型类和Mapper接口会使用泛型）。这些生成对象中的"by example"方法将支持几乎不受限制的动态的where子句。另外，这些生成的Java对象支持更多的JSE5.0特性，包含泛型和注解。 MyBatis3Simple： 使用这值的时候，和MyBatis3类似，除了生成的mapper仅仅具有非常基本的CRUD操作，但是不会有"by example"一类的方法和只有少量的动态SQL。 MyBatis3DynamicSql：使用这值的时候，MBG生成的对象会生成兼容MyBatis 3.4.2或更高版本，兼容Java8或者更高版本（例如，Java模型类和Mapper接口会使用泛型和其他Java8的特性像接口中的默认方法）。 注意：生成的Java代码运行时需要依赖 "MyBatis Dynamic SQL"支持的jar包。 其他：defaultModelType值为flat时，意味着没有“with BLOBs”和“with BLOBs”方法。 生成mapper作为注解mapper,不管&lt;javaClientGenerator&gt;的设置的类型是何值。 没有XML文件生成。&lt;sqlMapGenerator&gt;不是必须的，并且如果配置了会被忽略。 MyBatis Dynamic SQL 在运行时支持表注释，在每个查询方式而不是所有的方式。基于这个原因，&lt;table&gt;中的&lt;alias&gt;设置会被忽略。 Ibatis2Java2： 使用这值的时候，MBG会生成兼容iBATIS 2.2.0或更高版本（除了iBATIS 3），兼容还有Java2。 这些生成对象中的"by example"方法将支持几乎不受限制的动态的where子句。这些生成的对象不能100%和原生的Abator或其他的代码生成器生成的对象兼容。 Ibatis2Java5： 使用这值的时候，MBG会生成兼容iBATIS 2.2.0或更高版本（除了iBATIS 3），兼容JSE 5.0或更高版本的对象（例如Java模型类和Dao类会使用泛型）。这些生成对象中的"by example"方法将支持几乎不受限制的动态的where子句。 另外，这些生成器生成的Java对象支持JSE 5.0特性，包含泛型和注解。 这些生成的对象不能100%和原生的Abator或其他的代码生成器兼容。 如果您想创建一个完全不同的代码生成器，使用一个继承了org.mybatis.generator.api.IntrospectedTable接口的全限定类名替换该值。通过这个值，您可以创建您自己的代码生成器，然后插入到代码生成器引擎中。查阅 Extending MyBatis Generator页面获取更多信息。 introspectedColumnImpl：使用这个值去指定一个继承了org.mybatis.generator.api.IntrospectedColumn接口的全限定类名称。这可以修改代码生成器计算列信息时候的行为。 查阅 Extending MyBatis Generator页面获取更多信息。 --&gt; &lt;context id="context" targetRuntime="MyBatis3Simple"&gt; &lt;!-- &lt;context&gt;（有严格的配置顺序）下可以配置9种子元素&lt;property&gt;、&lt;plugin&gt;、&lt;commentGenerator&gt;、&lt;jdbcConnection&gt;、&lt;javaTypeResolver&gt;、&lt;javaModelGenerator&gt;、&lt;sqlMapGenerator&gt;、&lt;javaClientGenerator&gt;、&lt;table&gt;--&gt; &lt;!-- &lt;property&gt; 可选，在&lt;context&gt;下可以配置0个或者多个。支持的属性有autoDelimitKeywords、beginningDelimiter、endingDelimiterjava、FileEncoding、javaFormatter、xmlFormatter--&gt; &lt;!-- autoDelimitKeywords：默认值是false。如果是true，那么MGB会分隔SQL关键字，如果他们被用作表中的列名。 MBG维护了许多不同数据库的的SQL关键字列表。 然而，列表可能不是非常的全面。如果一个特殊的关键字没有在MBG的关键字列表中。您需要通过&lt;columnOverride&gt;(table元素中涉及到)强制分隔列。查看org.mybatis.generator.internal.db.SqlReservedWords这个类的源码查看MGB包含的关键字列表。 --&gt; &lt;property name="autoDelimitKeywords" value="true"/&gt; &lt;!-- beginningDelimiter： 默认值是双引号 (")。用作需要分隔符的SQL标识符开头的标识符分隔符的值。MBG会自动分割包含空格的SQL标识符。MGB还会自动分隔在 &lt;table&gt; 或 &lt;columnOverride&gt;中配置了具体要求的标识符。在Mysql中需要这两个默认值改为反单引号(`) --&gt; &lt;!-- endingDelimiter： 默认值是双引号 (")。用作需要分隔符的SQL标识符结束的标识符分隔符的值。MBG会自动分割包含空格的SQL标识符。MGB还会自动分隔在 &lt;table&gt; 或 &lt;columnOverride&gt;中配置了具体要求的标识符。在Mysql中需要这两个默认值改为反单引号(`) --&gt; &lt;property name="beginningDelimiter" value="`"/&gt; &lt;property name="endingDelimiter" value="`"/&gt; &lt;!-- javaFileEncoding： 设置要使用的Java文件的编码。新生成的Java文件会用这个编码写入到文件系统，如果Java文件已经存在并且执行合并操作，将使用这个编码进行读取。如果没有指定，就会使用平台的默认编码。查阅 java.nio.charset.Charset 获取可以选择的编码的信息。 --&gt; &lt;property name="javaFileEncoding" value="UTF-8"/&gt; &lt;!-- 最后两个javaFormatter和xmlFormatter属性可能会很有用，如果你想使用模板来定制生成的java文件和xml文件的样式，你可以通过指定这两个属性的值来实现。 --&gt; &lt;!-- javaFormatter 使用此属性来指定用户提供全限定类名用于生成Java文件。这个类必须继承 org.mybatis.generator.api.JavaFormatter 而且必须有一个默认（不含参数）的构造方法。每一个context都持有一个单独的javaFormatter的实例。默认的javaFormatter是org.mybatis.generator.api.dom.DefaultJavaFormatter。 默认的格式使用内置的Java DOM类的格式。 --&gt; &lt;property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/&gt; &lt;!-- xmlFormatter 使用此属性来指定用户提供全限定类名用于生成XML文件。 这个类必须继承 org.mybatis.generator.api.XmlFormatter 而且必须有一个默认（不含参数）的构造方法。每一个context都持有一个单独的xmlFormatter的实例。 默认的xmlFormatter 是org.mybatis.generator.api.dom.DefaultXmlFormatter。 默认的格式使用内置的xml DOM类的格式。 --&gt; &lt;property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/&gt; &lt;!-- &lt;plugin&gt; 元素可以配置0个或者多个，不受限制。 该元素用来定义一个插件。插件用于扩展或修改通过MBG生成的代码。插件将按在配置中配置的顺序执行。 关于插件开发的信息， 请参考Implementing Plugins页面。 关于MBG提供的插件信息，请参考Supplied Plugins页面。 该元素有1个必选属性： type： 实现插件的类的完全限定名。该类必须实现该接口 org.mybatis.generator.api.Plugin, 必须有一个公开默认的构造函数。注意，继承org.mybatis.generator.api.PluginAdapter这个适配器类比继承接口更容易扩展。 --&gt; &lt;!-- &lt;commentGenerator&gt; 可选，在&lt;context&gt;下最多配置一个。 该元素用来定义~注释生成器~的属性。~注释生成器~是用来给通过MBG生成的多种元素（Java属性，Java方法，XML元素等等）生成注释。默认的~注释生成器~将JavaDoc注释添加到所有生成的Java元素上，从而使Eclipse插件可以使用合并Java的功能。 此外，注释还会添加到每一个生成的XML元素中。 注释的目的还在于告诉用户这个元素是生成的，并且有可能重新生成（也就是说 - 他们不应该被修改）。 默认的实现是org.mybatis.generator.internal.DefaultCommentGenerator，默认的实现被设计成可扩展的，如果你想修改某些行为。 该元素有1个可选属性： type：可以指定用户的实现~注释生成器类~。这个类必须继承org.mybatis.generator.api.CommentGenerator接口。而且必须有一个默认的公共的构造函数。 这个属性接收默认的特殊值DEFAULT，会使用默认的实现类org.mybatis.generator.internal.DefaultCommentGenerator（这和不指定该属性的效果一样）。 --&gt; &lt;commentGenerator&gt; &lt;!-- 默认的~注释生成器~提供了几个可以用&lt;property&gt;设置的属性： suppressAllComments： 这个属性用来指定MBG生成的代码中是否包含任何注释。这个属性有以下可选值： false： 默认值。当这个属性是false或者没有指定时，所有生成的元素都会包含用来说明这是这些元素是生成的元素。 true： 当这个属性是true时，不会往生成的元素中添加任何注释。警告：如果suppressAllComments值设为true，那么所有的代码合并都会被禁用。 suppressDate： 这个属性用来指定MBG生成的注释中是否包含生成的时间戳。这个属性有以下可选值： false: 默认值。当这个属性是false或者没有指定时，所有元素生成注释时都会带着生成时间。 true: 当这个属性是true时，注释中不会添加时间戳。 警告，如果suppressAllComments值是true,这个选项将会被忽略 addRemarkComments： 这个属性用来指定MBG生成的代码中是包含数据库中表和列注释信息。这个属性有以下可选值： false： 默认值,当这个属性是false或者没有指定时，所有元素生成注释时都不会包含数据库中表和字段注释。 true： 当这个属性是true时，数据库中表和字段注释将会添加到生成的注释中。 警告，如果suppressAllComments值是true,这个选项将会被忽略并且1.3.3以上版本有效。 dateForma： 将日期写入生成的注释时要使用的日期格式字符串。这个字符串将用于构造java.text.SimpleDateFormat对象。这个对象的任何有效的字符串形式都可以在这里指定。默认情况下，日期字符串将使用来自java.util.Date上的toString()方法。 警告，如果suppressAllComments或者suppressDate的值是true,这个选项将会被忽略并且1.3.4以上版本有效。 --&gt; &lt;property name="addRemarkComments" value="true"/&gt; &lt;property name="dateFormat" value="该注释于yyyy年MM月dd日HH时mm分ss秒生成"/&gt; &lt;/commentGenerator&gt; &lt;!-- &lt;jdbcConnection&gt; 必选，在&lt;context&gt;下只能有1个。 该元素用于指定需要去映射表的数据库连接属性。MBG使用JDBC的数据库元数据类来发现您在配置中指定的表的属性。 （应该是使用默认的实现类org.mybatis.generator.internal.JDBCConnectionFactory） 该元素有2个必选属性： driverClass： 访问数据库的JDBC驱动程序的完全限定类名 connectionURL： 访问数据库的JDBC连接URL 该元素有2个可选属性： userId： 访问数据库的用户ID password： 访问数据库的密码 --&gt; &lt;jdbcConnection userId="$&#123;jdbc.username&#125;" password="$&#123;jdbc.password&#125;" driverClass="$&#123;jdbc.driver&#125;" connectionURL="$&#123;jdbc.url&#125;"&gt; &lt;!--此外该元素还可以接受多个&lt;property&gt;子元素，这里配置的&lt;property&gt;属性都会添加到JDBC驱动的属性中。--&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;connectionFactory&gt; 和&lt;jdbcConnection&gt;二选一 该元素用于指定需要映射表的数据库连接的连接工厂。MBG使用JDBC的数据库元数据类来发现您在配置中指定的表的属性。 每一个&lt;context&gt;都必须有一个&lt;jdbcConnection&gt;元素或者&lt;connectionFactory&gt;元素。 该元素有1个可选属性： type： 用于指定用户提供的数据库连接工厂，这个类必须继承org.mybatis.generator.api.ConnectionFactory接口。而且必须有一个默认的公共的构造函数。 这个属性接收默认的特殊值DEFAULT，会使用默认的实现类org.mybatis.generator.internal.JDBCConnectionFactory（这和不指定该属性的效果一样）。 IDEA中会有红色的提示，但是没有错。 &lt;connectionFactory&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="connectionURL" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="userId" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/connectionFactory&gt; --&gt; &lt;!-- &lt;javaTypeResolver&gt; 可选，在&lt;context&gt;下最多可以配置一个。 该元素用来定义~Java类型转换器~。~Java类型转换器~用来计算数据库中列信息的Java类型。默认的~Java类型转换器~试图将JDBC的DECIMAL和NUMERIC类型转换成用于使用的整数类型（Long, Integer, Short等）。如果这种行为不可取，可以将属性forceBigDecimals设置为true。如果你想要不同的默认行为，可以替换成自己实现的类。 该元素有1个可选属性： type：可以指定用户实现的~Java类型转换器~。这个类必须继承org.mybatis.generator.api.JavaTypeResolver接口。而且必须有一个默认的公共的构造函数。 这个属性接收默认的特殊值DEFAULT，会使用默认的实现类org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl（这和不指定该属性的效果一样）。 --&gt; &lt;javaTypeResolver&gt; &lt;!-- 默认的实现类中提供了1个可选属性： forceBigDecimals: 该属性用来指定MBG是否强制将DECIMAL和NUMERIC类型的字段转换为Java类型的java.math.BigDecimal而不是简单的整数类型。有以下2个可选值： false：默认值，转换规则为： 如果精度&gt;0或者长度&gt;18，就会使用java.math.BigDecimal 如果精度=0并且10&lt;=长度&lt;=18，就会使用java.lang.Long 如果精度=0并且5&lt;=长度&lt;=9，就会使用java.lang.Integer 如果精度=0并且长度&lt;5，就会使用java.lang.Short true： 一定会使用java.math.BigDecimal --&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- &lt;javaModelGenerator&gt;必选，在&lt;context&gt;下只能有1个。 该元素用于定义~java模型生成器~的属性。~java模型生成器~创建主键类、纪录类和 by Example查询类来匹配映射的表。 ~java模型生成器~根据IntrospectedTable(IntrospectedTable是MBG提供的一个比较基础的扩展类)来创建主键类、纪录类和 by Example查询类。 在MBG中，提供了几种默认的IntrospectedTable的实现，其实在context上设置的targetRuntime对应的就是不同的IntrospectedTable的实现，下面就是几种runtime和对应的IntrospectedTable关系： MyBatis3 (默认)：org.mybatis.generator.codegen.mybatis3.IntrospectedTableMyBatis3Impl MyBatis3Simple： org.mybatis.generator.codegen.mybatis3.IntrospectedTableMyBatis3SimpleImpl Ibatis2Java2： org.mybatis.generator.codegen.ibatis2.IntrospectedTableIbatis2Java2Impl Ibatis2Java5： org.mybatis.generator.codegen.ibatis2.IntrospectedTableIbatis2Java5Impl 注意，其中的IntrospectedTableMyBatis3Impl和IntrospectedTableMyBatis3SimpleImpl两个类是值得我们在自己扩展前仔细阅读的；当扩展了自己的IntrospectedTable之后，就可以在context的targetRuntime中配置自己的实现类的全限定名即可。 该元素有2个必选属性： targetPackage：生成实体类存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(&lt;table&gt;中会提到)。 targetProject：指定目标项目路径，可以是绝对路径或相对路径（如 targetProject="src/main/java"）。 --&gt; &lt;javaModelGenerator targetPackage="com.tzy777.testssm.entity" targetProject="src/main/java"&gt; &lt;!-- 该元素支持以下5个&lt;property&gt;子元素属性： constructorBased: 默认为false。该属性只对MyBatis3有效，如果true就会使用构造方法入参，如果false就会使用setter方式。这个属性会被&lt;table&gt;中的&lt;corresponding&gt;属性重写。 enableSubPackages: 默认为false。如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。 immutable: 默认为false。该属性只对MyBatis3有效，用来配置实体类属性是否可变，如果设置为true，那么constructorBased不管设置成什么，都会使用构造方法入参，并且不会生成setter方法。如果为false，实体类属性就可以改变。该属性可以被&lt;table&gt;中的 &lt;corresponding&gt;属性重写。 rootClass: 设置所有实体类的基类。如果设置，需要使用类的全限定名称。并且如果MBG能够加载rootClass，那么MBG不会覆盖和父类中完全匹配的属性。匹配规则：属性名完全相同、属性类型相同、属性有getter方法、属性有setter方法 trimStrings: 默认值为false。是否对数据库查询结果进行trim操作，如果设置为true就会生成类似这样public void setUsername(String username) &#123;this.username = username == null ? null : username.trim();&#125;的setter方法。可以被&lt;table&gt;或者&lt;columnOverride&gt;重写。 --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;property name="immutable" value="false"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- &lt;sqlMapGenerator&gt; 可选，该元素最多可以配置一个。 该元素被用于定义~SQL map生成器~属性。~SQL map生成器~为每一个映射的表创建一个MyBatis/iBATIS格式的SQL map的XML文件。 如果targetRuntime是iBATIS2，该元素必须配置一个。 如果targetRuntime是MyBatis3，只有当&lt;javaClientGenerator&gt;需要XML时，该元素必须配置一个。 如果没有配置&lt;javaClientGenerator&gt;，则使用以下的规则： 如果指定了一个&lt;sqlMapGenerator&gt;，那么MBG将只生成XML的SQL映射文件和实体类。 如果没有指定&lt;sqlMapGenerator&gt;， 那么MBG将只生成实体类。 该元素有2个必选属性：（和前面提过的&lt;javaModelGenerator&gt;的属性含义一样）。 targetPackage:生成SQL Map存放的包名，一般就是放在该包下。实际还会受到其他配置的影响(&lt;table&gt;中会提到)。 targetProject:指定目标项目路径，可以是绝对路径或相对路径（如 targetProject="src/main/resources"）。 --&gt; &lt;sqlMapGenerator targetPackage="config/mapper" targetProject="src\main\resources"&gt; &lt;!-- 该元素支持1个&lt;property&gt;子元素： enableSubPackages： 默认为false。如果true，MBG会根据catalog和schema来生成子包。如果false就会直接用targetPackage属性。 --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- &lt;javaClientGenerator&gt;可选，最多配置一个。 该元素该元素被用于定义~Java client生成器~属性。Java client生成器创建java接口和类，便于使用java model和XML map文件。 如果targetRuntime是iBATIS2，这些生成的对象采用DAO接口和实现类的形式 如果targetRuntime是MyBatis，生成的对象采用mapper接口的形式。 如果不配置该元素，就不会生成Mapper接口。 该元素有3个必选属性： targetPackage：用于存放生成接口的包名，一般就是放在该包下。 targetProject：指定目标项目路径，可以是绝对路径或相对路径（如 targetProject="src/main/java"）。 type:可以指定用户的实现~Java client生成器类~。这个类必须继承org.mybatis.generator.codegen.AbstractJavaClientGenerator接口。而且必须有一个默认的公共的构造函数。 &lt;context&gt; targetRuntime 是 MyBatis3: type="XMLMAPPER", 生成的对象是 MyBatis 3.x 映射器基础结构的 Java接口。 这些接口将会依赖于生成的XML文件。 type="ANNOTATEDMAPPER", 生成的对象是 MyBatis 3.x 映射器基础结构的 Java接口。 这些接口将会基于注解和 MyBatis 3.x SqlProviders。不会有XML文件生成。（注：就是纯接口使用注解的形式，不会有XML文件）。 依赖 MyBatis 3.0.4 或更高版本。 type="MIXEDMAPPER", 生成的对象是 MyBatis 3.x 映射器基础结构的 Java接口。 这些接口将基于注解和XML的混合形式。 注解将会用在简单注解可以实现的地方。 此客户端（接口中）不会生成SqlProvider，所有复杂的动态SQL都会生成在XML中。依赖 MyBatis 3.0.4 或更高版本。 &lt;context&gt; targetRuntime 是 MyBatis3Simple:: type="XMLMAPPER", 生成的对象是 MyBatis 3.x 映射器基础结构的 Java接口。 这些接口将会依赖于生成的XML文件。 type="ANNOTATEDMAPPER", 生成的对象是 MyBatis 3.x 映射器基础结构的 Java接口。 这些接口将会基于注解和 MyBatis 3.x SqlProviders。不会有XML文件生成。（注：就是纯接口使用注解的形式，不会有XML文件）。 依赖 MyBatis 3.0.4 或更高版本。 &lt;context&gt; targetRuntime 是 Ibatis2Java2 or Ibatis2Java5:: type="IBATIS", 生成的对象符合iBATIS的DAO框架（不建议使用）。 type="GENERIC-CI", 生成的对象将只依赖于SqlMapClient，通过构造方法注入。生成的对象是DAO接口和实现类。 type="GENERIC-SI", 生成的对象将只依赖于SqlMapClient，通过setter方法注入。生成的对象是DAO接口和实现类。 type="SPRING" 生成的对象符合Spring的DAO接口 该元素有1个可选属性： implementationPackage:如果指定了该属性，实现类就会生成在这个包中。这默认的生成器中属性（property）enableSubPackages控制着如何去创建包。 --&gt; &lt;javaClientGenerator targetPackage="com.tzy777.testssm.dao" type="XMLMAPPER" targetProject="src/main/java"&gt; &lt;!--该元素支持以下5个&lt;property&gt;子元素属性： enableSubPackages： 默认值是 false。这个属性用来选择MGB是否根据catalog和schema的introspected表来生成不同的Java包。例如，假设某个表MYTABLE在MYSCHMA的schema中，也假设targetPackage属性的值设置为"com.mycompany"。 如果此属性为true，为这个表生成的DAO接口和类将被放置在包"com.mycompany.myschema"中。 如果此属性是false，生成的SQL映射将被放在"com.mycompany" schema中。 exampleMethodVisibility： 此属性用来设置不同"ByExample"方法的可见性 - selectByExample, deleteByExample等等。 如果没有指定，这些方法将会是公开的的，并将在接口中声明。 此属性使您可以隐藏这些方法如果您只想使用它们来执行其他专门的方法。如果目标运行环境是MyBatis3，则将忽略此属性。 public： 默认值，生成实现类中的方法将是公开的，并将该接口中声明的方法。 private： 生成实现类中的方法将是private的，也不会在接口中声明。 protected： 生成实现类中的方法将是protected的，也不会在接口中声明。 default： 生成实现类中的方法将是private的，也不会在接口中声明。 methodNameCalculator： 此属性用于设置一个~方法名称计算器~。 ~方法名称计算器~可以用来为DAO方法提供不同的名称。 您可以选择一个预定义的值。 如果提供的选项都适合您的环境， 也可以指定一个实现了org.mybatis.generator.api.DAOMethodNameCalculator接口的完全限定名称。如果目标运行环境是MyBatis3，则将忽略此属性。 default这是默认值生成的方法名称会很简单("insert", "updateByPrimaryKey"等等)。 extended 生成的方法名称将包括与方法关联的实体对象的名称("insertWidget", "updateWidgetByPrimaryKey"等等)。 rootInterface： 此属性用于指定一个所有生成的接口都继承的父接口。 这个值可以通过&lt;table&gt;配置的 rootInterface 属性覆盖。重要: MBG 不验证接口是否存在或者是否是一个有效的接口。如果指定，这个属性值应该是一个全限定接口名称(例如 com.mycompany.MyRootInterface)。 useLegacyBuilder， 默认值是 false。如果为true，那么注解客户端（接口）将使用SqlBuilder为MyBatis生成动态SQL。 在MyBatis 3.2或以后版本，这个SqlBuilder被废弃了，用了一个新的SQL类替代。 如果是false，MBG会使用新的SqlBuilder生成客户端代码。 --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!--如果目标运行环境是MyBatis3，则将忽略此属性。--&gt; &lt;property name="methodNameCalculator" value="extended"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- &lt;table&gt; 必选，该元素至少要配置一个，可以配置多个。 该元素用来从映射的数据库中选择一个表。选定的表会生成如下的这些对象： 一个 MyBatis/iBATIS 格式的SQL映射文件 一组根据“model”生成的表的类： 一个和表的主键匹配的类(如果表有主键)。 一个包含了非主键字段和非BLOB字段的类，如果存在主键类，这个类就会继承主键类。 如果表中包含BLOB字段，就会有一个包含了BLOB字段的类。这个类会根据表的配置继承上面的一个或两个类。 一个用于不同的"by example"方法(selectByExample, deleteByExample)生成动态查询条件的类。 (可选) 一个DAO接口或者类 数据库标识符： 该元素有1个必选的属性： tableName: 数据库表的名称(不包括schema或catalog)。如果需要，指定的值可以包含SQL通配符。 该元素18个可选属性： schema： 数据库schema，如果你的数据库不使用schema，或者有一个默认的schema您不需要设置schema。如果需要，指定的值可以包含SQL通配符。如果设置了该值，生成SQL的表名会变成如schema.tableName的形式。 catalog： 数据库catalog，如果您的数据库不使用 catalog，或者有一个默认的catalog，您就不需要设置catalog。如果设置了该值，生成SQL的表名会变成如catalog.tableName的形式。 alias： 如果指定，这个值会用在任何生成的SQL查询语句的表的别名和列名上。列名会被别名化，用alias_actualColumnName(别名_实际列名)这种模式。 domainObjectName：生成对象的基本名称。如果没有指定，MBG会自动根据表名来生成名称。 mapperName： MyBatis3生成的mapper 类和XML文件名称，如果没有指定，无论domain object name是什么，都会在后面加上"Mapper"。 版本1.3.4以上有效。 sqlProviderName：MyBatis3生成的SQL provider 类， 如果没有指定，无论domain object name是什么，都会在后面加上"SqlProvider"。版本1.3.4以上有效。 enableXXX： XXX代表多种SQL方法，共有10个。该属性用来指定是否生成对应的XXX语句。 selectByPrimaryKeyQueryId: 这个值会以"'&lt;value&gt;' as QUERYID"这种形式被添加到通过 主键查询的语句的select列中。 这可能对在运行时的DBA跟踪工具中标记查询有用。 如果您使用这个值，您需要为MBG生成的每一个查询指定一个唯一的id。 selectByExampleQueryId: 这个值会以"'&lt;value&gt;' as QUERYID"这种形式被添加到通过Example查询的语句的select列中。 这可能对在运行时的DBA跟踪工具中标记查询有用。 如果您使用这个值，您需要为MBG生成的每一个查询指定一个唯一的id。 modelType:如果您需要，这个值可以用来重写默认的模型类型。如果没有指定，MBG将会生成基于&lt;context&gt;的defaultModelType值的实体对象。模型类型定义了MBG如何生成实体类。有一些模型类型MGB会为每个表生成一个单独的实体类。 另外一些模型，MGB会根据表结构生成不同的一些类。 这个属性有以下可选值： hierarchical :如果表有主键,那么该模型会产生一个单独的主键实体类,如果表还有BLOB字段,则会为表生成一个包含所有BLOB字段的单独的实体类,然后为所有其他的字段生成一个单独的实体类。MBG会在所有生成的实体类之间维护一个继承关系（注：BLOB类 继承 其他字段类 继承 主键类）。 conditional :这个模型和hierarchical类似，除了如果那个单独的类将只包含一个字段，将不会生成一个单独的类。 因此,如果一个表的主键只有一个字段,那么不会为该字段生成单独的实体类,会将该字段合并到基本实体类中。 flat :该模型为每一张表只生成一个实体类。这个实体类包含表中的所有字段。 escapeWildcards： 默认false。这个属性表示当查询列时，是否对schema和表名中的SQL通配符 ('_' and '%') 进行转义。 对于某些驱动当schema或表名中包含SQL通配符时（例如，一个表名是MY_TABLE，有一些驱动需要将下划线进行转义）是必须的。 delimitIdentifiers： 默认false。是否给标识符增加分隔符。但是当catalog,schema或tableName中包含空白时，默认为true delimitAllColumns： 默认false。是否对所有列添加分隔符。 这是一种给每个列添加&lt;columnOverride&gt;来指定列需要被分隔的替代方式。 这对类似PostgreSQL这种使用小写标识符的数据库很有用。分隔符在 &lt;context&gt; 元素上指定。 --&gt; &lt;table tableName="%" enableCountByExample="false" enableDeleteByExample="false" enableSelectByExample="false" enableUpdateByExample="false"&gt; &lt;!-- 该元素包含13个可用的&lt;property&gt;子元素，可选属性为： constructorBased: 默认值是false。此属性用于选择代码生成器是否生成接受类中的每个字段的值的类的构造函数。此外，SQL结果映射也会为每个字段生成使用构造方法而不是"setter"的方式。 和&lt;javaModelGenerator&gt;中的属性含义一样。 此属性仅适用于MyBatis3，iBATIS2将会被忽略。如果"immutable"属性设置为"true"，这个属性将会被忽略。 ignoreQualifiersAtRuntime: 默认值是false。如果设置为true，MBG不会将schema或catalog添加到生成SQL中的表名上。如果您有几个schemas中的表具有相同的名称，这是非常有用的。您可以使用MBG生成基于在一个schema上的表，但是运行时不包含schema。 immutable: 和&lt;javaModelGenerator&gt;中的属性含义一样。 modelOnly: 此属性用于配置是否为表只生成实体类。如果设置为true就不会有Mapper接口。如果配置了&lt;sqlMapGenerator&gt;，并且modelOnly为true，那么MBG只会为表在SQL XML映射文件中生成实体对象的映射元素(&lt;resultMap&gt;)。如果为true还会覆盖属性中的enableXXX方法，将不会生成任何CRUD方法。 rootClass: 和&lt;javaModelGenerator&gt;中的属性含义一样。 rootInterface: 和&lt;javaClientGenerator&gt;中的属性含义一样。 runtimeCatalog: 如果你给这个属性设定了值，那么BGM用会用这个Catalog在生成的SQL语句中而不是使用之前设定的值。这是非常有用的。 runtimeSchema: 如果你给这个属性设定了值，那么BGM用会用这个Schema在生成的SQL语句中而不是使用之前设定的值。这是非常有用的。 runtimeTableName： 如果你给这个属性设定了值，那么BGM用会用这个tableName在生成的SQL语句中而不是使用之前设定的值。这是非常有用的，。 selectAllOrderByClause: 该属性值会追加到selectAll方法后的SQL中，会直接跟order by拼接后添加到SQL末尾。这个值只有在MyBatis3Simple时才有效 trimStrings 和&lt;javaModelGenerator&gt;中的属性含义一样。这个默认的值从 &lt;javaModelGenerator&gt;继承下来，否则为false。 useActualColumnNames: 如果设置为true,那么MBG会使用从数据库元数据获取的列名作为生成的实体对象的属性。 如果为false(默认值)，MGB将会尝试将返回的名称转换为驼峰形式。 在这两种情况下，可以通过&lt;columnOverride&gt;元素显示指定，在这种情况下将会忽略这个（useActualColumnNames）属性。 useCompoundPropertyNames: 默认是false。如果是true,那么MBG生成属性名的时候会将列名和列备注接起来. 这对于那些通过第四代编程语言自动生成列(例如:FLD22237),但是备注包含有用信息(例如:"customer id")的数据库来说很有用.在这种情况下,MBG会生成属性名FLD2237_CustomerId。 --&gt; &lt;!-- 除了&lt;property&gt;子元素外，&lt;table&gt;还包含以下子元素： 1.&lt;generatedKey&gt;元素,这个元素最多可以配置一个。这个元素用来指定从（identity字段或者sequences序列）自动生成主键的值。如果指定这个元素，MBG在生成insert的SQL映射文件中插入一个&lt;selectKey&gt;元素。 这个元素非常重要，这个元素包含下面2个必选属性： column: 生成列的列名。 sqlStatement: 将返回新值SQL语句。如果这是一个identity列，您可以使用其中一个预定义的的特殊值。预定义值如下： Cloudscape、DB2、DB2_MF、Derby、HSQLDB、Informix、MySql、SqlServer、SYBASE、 JDBC:这会配置MBG使用MyBatis3支持的JDBC标准的来生成主键。这是一个独立于数据库获取标识列中的值的方法。 重要: 只有当目标运行为MyBatis3时才会产生正确的代码。 如果与iBATIS2一起使用目标运行时会产生运行时错误的代码。 这个元素包含下面2个必选属性： identity: 默认值是false。当设置为true时,该列会被标记为identity列，并且&lt;selectKey&gt;元素会被插入在insert后面。当设置为false时，&lt;selectKey&gt;会插入到insert之前（通常是序列）。重要: 即使您type属性指定为post，您仍然需要为identity列将该参数设置为true。 这将标志MBG从插入列表中删除该列。 type: type=post and identity=true的时候生成的&lt;selectKey&gt;中的order=AFTER,当type=pre的时候，identity只能为false，生成的&lt;selectKey&gt;中的order=BEFORE。可以这么理解，自动增长的列只有插入到数据库后才能得到ID，所以是AFTER,使用序列时，只有先获取序列之后，才能插入数据库，所以是BEFORE。 https://blog.csdn.net/u014365133/article/details/78884751有不同的配置对应的生成的结果。 2.&lt;columnRenamingRule&gt; 该元素最多配置一个 MBG使用&lt;columnRenamingRule&gt;元素在生成映射表中相应的属性之前可以对列进行重命名。这对那些存在同一前缀的字段想在生成属性名时去除前缀的表非常有用。 例如假设一个表包含以下的列：CUST_BUSINESS_NAME，CUST_STREET_ADDRESS，CUST_CITY，CUST_STATE 如果生成的所有属性名中如果都包含CUST的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则来移除：&lt;columnRenamingRule searchString="^CUST_" replaceString="" /&gt; 注意，在内部，MBG使用java.util.regex.Matcher.replaceAll方法实现这个功能。请参阅正则表达式在Java中的方法和例子的相关文档。 当&lt;columnOverride&gt;匹配一列时，元素&lt;columnRenamingRule&gt;会被忽略。&lt;columnOverride&gt;优先于重命名的规则。 如果指定该选项，重命名规则会在生成属性名前替换列名。 计算出的属性名可能不同，这取决于 &lt;table&gt; 元素上的 "useActualColumnNames"属性。 下表显示了如果重命名规则用于字段集上时不同的值: Column Name Property if useActualColumnNames="true" Property if useActualColumnNames="false" CUST_BUSINESS_NAME BUSINESS_NAME businessName CUST_STREET_ADDRESS STREET_ADDRESS streetAddress CUST_CITY CITY city CUST_STATE STATE state 该元素有1个必选属性： searchString:定义将被替换的字符串的正则表达式。 该元素有1个可选属性： replaceString:这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。 5.&lt;domainObjectRenamingRule&gt; MBG使用&lt;domainObjectRenamingRule&gt;元素在生成的映射的domain object名称(pojo对象，实体类对象)时可以重命名表的名称。这对那些存在同一前缀的表想在生成domain object名称时去除前缀的非常有用。 例如假设存在如下几张表：SYS_USER、SYS_ROLE、SYS_FUNCTION 如果生成的所有domain object名称(pojo对象，实体类对象)中如果都包含CUST的前缀可能会让人不爽。这些前缀可以通过如下方式定义重命名规则来移除：&lt;domainObjectRenamingRule searchString="^Sys" replaceString="" /&gt; 注意，在内部，MBG使用java.util.regex.Matcher.replaceAll方法实现这个功能。请参阅正则表达式在Java中的方法和例子的相关文档。 如果指定该选项，这个重命名对象将会重命名所有基于domain object的名称。假设存在一个表SYS_USER : Class Before using rename rule After using rename rule Domain Object SysUser User Key SysUserKey UserKey Blob SysUserWithBLOBs UserWithBLOBs Example SysUserExample UserExample Mapper SysUserMapper UserMapper 该元素有1个必选属性： searchString:定义将被替换的字符串的正则表达式。 该元素有1个可选属性： replaceString:这是一个用来替换搜索字符串列每一个匹配项的字符串。如果没有指定，就会使用空字符串。 3.&lt;columnOverride&gt; 该元素最多配置一个 MBG使用&lt;columnOverride&gt;元素将映射表中某些属性默认计算的值更改为指定的值。 该元素有1个必选属性: column: 要重写的列名。 该元素6个可选属性： property: 要使用的Java属性的名称。如果没有指定，MBG会根据列名生成。例如，如果一个表的一列名为STRT_DTE，MBG会根据&lt;table&gt;的useActualColumnNames属性生成STRT_DTE或strtDte。 javaType: 该列属性值为完全限定的Java类型。如果需要，这可以覆盖由&lt;JavaTypeResolver&gt;计算出的类型。对某些数据库来说，这是必要的用来处理“奇怪的”数据库类型(例如MySql的unsigned bigint类型需要映射为java.lang.Object)。 jdbcType: 该列的JDBC类型(INTEGER, DECIMAL, NUMERIC, VARCHAR等等)。 如果需要，这可以覆盖由&lt;JavaTypeResolver&gt;计算出的类型。 对某些数据库来说，这是必要的用来处理怪异的JDBC驱动(例如DB2的LONGVARCHAR类型需要映射为VARCHAR..(iBATIS))。 typeHandler: 用户定义的需要用来处理这列的类型处理器。它必须是一个继承iBATIS的TypeHandler类或TypeHandlerCallback接口（该接口很容易继承）的全限定的类名。如果没有指定或者是空白，iBATIS会用默认的类型处理器来处理类型。重要:MBG不会校验这个类型处理器是否存在或者可用。MGB只是简单的将这个值插入到生成的SQL映射的配置文件中。 delimitedColumnName: 指定是否应在生成的SQL的列名称上增加分隔符。 如果列的名称中包含空格，MGB会自动添加分隔符，所以这个重写只有当列名需要强制指定为一个合适的名字或者列名是数据库中的保留字时才是必要的。 isGeneratedAlways: 默认值是false,1.3.4以上版本有效。指定该列是否是数据库中的GENERATED ALWAYS列。如果这个列是GENERATED ALWAYS列，MBG不会映射这个列的insert或者update语句。 该元素包含1个可用的&lt;property&gt;子元素，可选属性为： trimStrings: 默认值从&lt;javaModelGenerator&gt;或者中&lt;table&gt;的属性中继承，否则默认值是false。此属性用于MBG时否对从数据库返回的字符字段进行trim操作。这对您的数据库使用CHAR字段而不是VARCHAR字段中存储数据是非常有用的。当这个值是true时MBG会对列进行trim操作，这个值会重写&lt;javaModelGenerator&gt;或者&lt;table&gt;层级上的设置。 4.&lt;ignoreColumn&gt; 该元素可选。 &lt;ignoreColumn&gt;元素用来告诉MBG忽略映射表的的某些列。没有SQL语句会反应到该列，Java模型对象不会有改属性。 该元素有一个必选属性： column:要忽略的列名。 该元素有一个必选属性： delimitedColumnName: 匹配列名的时候是否区分大小写。如果为true则区分。默认值为false，不区分大小写。 5.&lt;ignoreColumnsByRegex&gt; --&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt;]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架配置]]></title>
    <url>%2F2019%2F06%2F14%2FSpringMVC%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[web.xml介绍和版本修改 web.xml的模式文件是由Sun公司定义的，每个web.xml文件的根元素中，都必须标明这个 web.xml使用的是哪个模式文件。其它的元素都放在之中。 web.xml的模式文件中定义的标签并不是定死的，模式文件也是可以改变的，一般来说，随着web.mxl模式文件的版本升级，里面定义的功能会越来越复杂，标签元素的种类肯定也会越来越多，但有些不是很常用的，我们只需记住一些常用的并知道怎么配置就可以了。 使用IDEA中创建maven web项目中的web.xml的版本比较低。打开WEB-INF\下的web.xml文件，根据需要更改一下web.xml的版本，可以支持更高级的一些语法，下面是web.xml的3.1版本： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt; 可以参考idea中web.xml默认版本问题解决来解决这个问题。 一般的web工程中都会用到web.xml，web.xml主要用来配置Filter、Listener、Servlet等。但是要说明的是web.xml并不是必须的，一个web工程可以没有web.xml文件。 web工程加载web.xml过程 web工程加载的顺序与元素节点在文件中的配置顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。WEB容器的加载顺序是：ServletContext -&gt; context-param -&gt; listener -&gt; filter -&gt; servlet。并且这些元素可以配置在文件中的任意位置。加载过程顺序如下： web.xml配置配置servlet servlet标签用于指定此Web应用的servlet相关配置，这个配置相当重要。servlet-name标签指定此servlet的名字，servlet-class指定servlet的类，这个类开发者可以自己写，一般会继承HttpServlet类，用来初始化整个Web项目和接受http请求并处理，SpringMVC项目中用DispatcherServlet类(前端控制器)。init-param标签里面可以配置一些参数。load-on-startup标签指定当前Web应用启动时装载Servlet的次序，它的内容必须是整数，当这个数&gt;=0时，容器会按数值从小到大依次加载。如果数值&lt;0或没有指定，容器将在用户首次访问时加载这个servlet类。 servlet-mapping标签可定义servlet映射，里面的servlet-name必须与前面的名字一致，url-pattern指定servlet映射的路径。 在用Tomcat启动整个web项目时，当配置了load-on-startup标签并且里面的数字&gt;=0时，会加载此servlet类，创建类的实例，调用init()方法初始化init-param标签里面的配置信息，此初始化在整个servlet生命周期中只会进行一次。如果未配置load-on-startup标签或数字&lt;0时，Tomcat启动时不会加载此servlet类，当然也就不会调用init()方法进行初始化，当用户首次访问时会加载类并初始化，所以此时第一次访问时可能会加载很慢。 12345678910111213141516171819202122232425&lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--定义Servlet的初始化参数(包括参数名和参数值),一个&lt;servlet&gt;元素里可以有多个&lt;init-param&gt;元素。 contextConfigLocation配置SpringMVC加载的配置文件(配置处理器、映射器和适配器等等)。 若不配置，默认加载WEB-INF/servlet名称-servlet.xml(mvc-dispatcher-servlet.xml)。 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;!--&lt;servlet-mapping&gt; 用来定义servlet所对应的URL--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!--指定servlet所对应的URL 第一种: *.action,访问以.action结尾，由DispatcherServlet进行解析 第二种: /,所有访问的地址由DispatcherServlet进行解析，对静态文件的解析需要配置不让DispatcherServlet进行解析， 使用此种方式和实现RESTful风格的url 第三种: /*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由DispatcherServlet解析jsp地址， 不能根据jsp页面找到handler，会报错 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置filter filter标签内部配置过滤器，filter-name标签指定此过滤器的名字，filter-class标签指定此过滤器指向的类，此类必须实现javax.servlet.Filter接口。filter-mapping标签用来关联一个或多个servlet或jsp页面。注意无论有多少filter-mapping，他们的filter-name必须与前面的名字一致。 1234567891011121314151617&lt;!--为了能够处理中文的post请求，配置一个encodingFilter，以避免post请求中文出现乱码情况--&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; SpringMVC配置文件 在classpath下(resources文件夹下)的springmvc.xml中或者web.xml同级目录下的 mvc-dispatcher-servlet.xml中配置 注解开发 开启springmvc注解模式，由于我们利用注解方法来进行相关定义，可以省去很多的配置： 123456&lt;!--注解映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;&lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;&lt;!-- 在实际开发，使用&lt;mvc:annotation-driven&gt;代替上边处理器映射器和适配器配置。 --&gt;&lt;mvc:annotation-driven/&gt; 静态资源访问12&lt;!-- 静态资源(js、image等)的访问 --&gt;&lt;mvc:default-servlet-handler/&gt; 配置处理器 首先加入component-scan标签，指明controller所在的包，并扫描其中的注解 12&lt;!--指明 controller 所在包，并扫描其中的注解--&gt;&lt;context:component-scan base-package="com.gaussic.controller"/&gt; 视图解析器123456&lt;!--ViewResolver 视图解析器,用于支持Servlet、JSP视图解析--&gt;&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 关于controller如何找到视图文件，这里需要详细的说明。在 controller 的一个方法中，返回的字符串定义了所需访问的jsp的名字（如上面的index）。在jspViewResolver中，有两个属性，一个是prefix，定义了所需访问的文件路径前缀，另一是suffix，表示要访问的文件的后缀，这里为 .jsp。那么，如果返回字符串是 xxx ，SpringMVC就会找到 /WEB-INF/pages/xxx.jsp 文件。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类加载机制]]></title>
    <url>%2F2018%2F11%2F12%2FJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java虚拟机类加载机制 感谢朱小厮和xixicat 代码思考123456789101112131415161718192021222324252627282930public class NotInitialization&#123; public static void main(String[] args) &#123; System.out.println(SubClass.value); &#125; public static class SSClass&#123; static &#123; System.out.println("SSClass Static Block"); &#125; &#125; public static class SuperClass extends SSClass&#123; static &#123; System.out.println("SuperClass Static Block"); &#125; public static int value = 123; public SuperClass() &#123; System.out.println("init SuperClass"); &#125; &#125; public static class SubClass extends SuperClass&#123; static &#123; System.out.println("SubClass Static Block"); &#125; static int a; public SubClass() &#123; System.out.println("init SubClass"); &#125; &#125;&#125; 输出结果 123SSClass Static BlockSuperClass Static Block123 也许有人会疑问：为什么没有输出SubClass Static Block。解释一下：对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。上面就牵涉到了虚拟机类加载机制。如果有兴趣，可以继续看下去。 双亲委派模型类加载器种类 从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader),这个类加载器使用c++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader 1、启动类加载器（Bootstrap ClassLoader）:这个类加载器负责加载lib目录中的。 2、扩展类加载器（Extension ClassLoader）:这个类加载器负责加载libext目录中的。 3、应用程序类加载器（Application ClassLoader）:这个类加载器负责加载用户类路径上所指定的类库。 4、自定义类加载器 程序中如果没有显式指定类加载器的话，默认是AppClassLoader来加载，它负责加载ClassPath目录中的所有类型，如果被加载的类型并没有在ClassPath目录中时，抛出java.lang.ClassNotFoundException异常。 一般是继承ClassLoader，如果要符合双亲委派规范，则重写findClass方法；要破坏的话，重写loadClass方法。 双亲委派模型的工作过程 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 使用这种方式的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个全限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。 类加载过程 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示。 加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。 加载在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情： 1.通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）； 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证 验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作： 1.文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 2.元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 4.符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为： 1public static int value=123; 那变量value在准备阶段过后的初始值为0而不是123.因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行。 至于“特殊情况”是指：public static final int value=123，即当类字段的字段属性是ConstantValue时，会在准备阶段初始化为指定的值，所以标注为final之后，value的值在准备阶段初始化为123而非0. 解析 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。这个阶段可以在初始化之后再执行。 初始化 类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主观计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器&amp;ltclinit&amp;rt()方法的过程. clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下： 12345678public class Test &#123; static &#123; i=0; //这句编译器会报错：Illegal forward reference（非法向前引用） System.out.println(i); &#125; static int i=1;&#125; 那么去掉报错的那句，改成下面： 1234567891011public class Test &#123; static &#123; i=0; //这句编译器会报错：Cannot reference a field before it is defined（非法向前应用） //System.out.println(i); &#125; static int i=1; public static void main(String args[]) &#123; System.out.println(i); &#125;&#125; 输出结果是什么呢？当然是1啦~在准备阶段我们知道i=0，然后类初始化阶段按照顺序执行，首先执行static块中的i=0,接着执行static赋值操作i=1,最后在main方法中获取i的值为1。 clinit()方法与实例构造器linit()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类clinit()方法执行之前，父类的clinit()方法已经执行完毕，回到本文开篇的举例代码中，结果会打印输出：SSClass就是这个道理。 由于父类的clinit()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。 clinit()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产clinit()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成clinit()方法。但接口与类不同的是，执行接口的clinit()方法不需要先执行父接口的clinit()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的clinit()方法。 虚拟机会保证一个类的clinit()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其他线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。如果在一个类的clinit()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。 12345678910111213141516171819202122232425262728public class DealLoopTest &#123; static class DeadLoopClass &#123; static &#123; if(true) &#123; System.out.println(Thread.currentThread()+"init DeadLoopClass"); while(true) &#123; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Runnable script = new Runnable()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread()+" start"); DeadLoopClass dlc = new DeadLoopClass(); System.out.println(Thread.currentThread()+" run over"); &#125; &#125;; Thread thread1 = new Thread(script); Thread thread2 = new Thread(script); thread1.start(); thread2.start(); &#125;&#125; 运行结果:（即一条线程在死循环以模拟长时间操作，另一条线程在阻塞等待） 123Thread[Thread-0,5,main] startThread[Thread-1,5,main] startThread[Thread-0,5,main]init DeadLoopClass 需要注意的是，其他线程虽然会被阻塞，但如果执行()方法的那条线程退出()方法后，其他线程唤醒之后不会再次进入()方法。同一个类加载器下，一个类型只会初始化一次。将上面代码中的静态块替换如下： 123456789101112131415161718192021222324252627import java.util.concurrent.TimeUnit;public class DealLoopTest &#123; static &#123; System.out.println(Thread.currentThread() + "init DeadLoopClass"); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Runnable script = new Runnable()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread()+" start"); DealLoopTest dlc = new DealLoopTest(); System.out.println(Thread.currentThread()+" run over"); &#125; &#125;; Thread thread1 = new Thread(script); Thread thread2 = new Thread(script); thread1.start(); thread2.start(); &#125;&#125; 运行结果 12345Thread[main,5,main]init DeadLoopClassThread[Thread-1,5,main] startThread[Thread-1,5,main] run overThread[Thread-0,5,main] startThread[Thread-0,5,main] run over 类初始化的时机 1.JVM启动包含main方法的启动类时。 2.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。(接口例外) 3.调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）,如果类没有进行过初始化，则需要先触发其初始化。 4.遇到new,getstatic,putstatic,invokestatic这失调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候 读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候 调用一个类的静态方法的时候 5.当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。 不会触类的初始化的情况 1.开篇已经举了一个范例：通过子类引用父类的静态字段，不会导致子类初始化。 ２.通过数组定义来引用类，不会触发此类的初始化：（SuperClass类已在本文开篇定义） 12345public class NotInitialization&#123; public static void main(String[] args)&#123; SuperClass[] sca = new SuperClass[10]; &#125;&#125; ３.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 1234567891011public class NotInitialization1 &#123; public static void main(String[] args)&#123; System.out.println(ConstClass.HELLOWORLD); &#125; public static class ConstClass&#123; static&#123; System.out.println("ConstClass init!"); &#125; public static final String HELLOWORLD = "hello world"; &#125;&#125; 运行结果： 1hello world]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务]]></title>
    <url>%2F2018%2F11%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[数据库事务正确执行的四个基本要素(ACID)原子性(atomicity) 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成， 不会结束在中间某个环节。事务在执行过程中发生错误，会被 回滚 （Rollback）到事务开 始前的状态，就像这个事务从来没有执行过一样。 一致性(Consistency) 在事务开始和完成时，数据库中的数据都保持一致的状态，数据的完整性约束没有被破坏。（事务的执行使得数据库从一种正确状态转换成另一种正确状态）。具体来说就是，比如表与表之间存在外键约束关系，那么你对数据库进行的修改操作就必需要满足约束条件，即如果你修改了一张表中的数据，那你还需要修改与之存在外键约束关系的其他表中对应的数据，以达到一致性。 隔离性(Isolation) 一个事务的执行不能被其他事务干扰。关于事务的隔离性数据库提供了四种隔离级别。 持久性(Durability) 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，并不会被回滚。 并发事务带来的问题(1)更新丢失 两个事务 Tl 和 T2 读入同一数据并修改，T2 提交的结果覆盖了 Tl 提交的结果，导致 Tl 的修改被丢失。 (2)脏读 事务 Tl 修改某一数据，并将其写回磁盘(事务T1还未提交)，事务 T2 读取同一数据后，Tl 由于某种原因被撤销，这时 Tl 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致，则 T2 读到的数据就为“脏”数据，即不正确的数据。 (3)不可重复读 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次相同的查询读到的数据是不一样的，因此称为是不可重复读。不可重复读的重点是修改。 (4)幻读 和不可重复读类似，重点在于新增或者删除。 数据库事务的隔离级别 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发(读)问题。 (1)读未提交数据(Read uncommitted) 允许事务读取未被其他事务提交的变更，可能有脏读，不可重复读和幻读的问题。 (2)读已提交数据(Read committed) 允许事务读取已经被其他事务提交的变更，可以避免脏读，可能有不可重复读和幻读的问题。 (3)可重复读(Repeatable read，Mysql 的默认隔离级别) 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新(不能禁止其他事务对数据表进行插入和删除操作)，可以避免脏读和不可重复读，可能会有幻读。 (4)可串行化(Serializable) 所有事务都一个接一个地串行执行。可以避免脏读，不可重复读，幻读。 更改MySQL的默认事务隔离级别 大多数的数据库系统的默认事务隔离级别都是：Read committed，而MySQL的默认事务隔离级别是：Repeatable Read。 查询mysql事务的隔离级别 1select @@tx_isolation 更改事务的隔离级别 1SET session TRANSACTION ISOLATION LEVEL Serializable; 将MySQL中的事务隔离级别改变成：Serializable，范围是当前session。 1set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable | Serializable; 如果选择global，意思是此语句将应用于之后的所有session，而当前已经存在的session不受影响。如果选择session，意思是此语句将应用于当前session内之后的所有事务。如果什么都不写，意思是此语句将应用于当前session内的下一个还未开始的事务。 数据库的锁 锁是一种并发控制技术，锁是用来在多个用户同时访问同一个数据的时候保护数据的。 (1)按照锁的类型(数据库的锁机制) 共享(S)锁(也叫读锁)：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S 锁立即被释放。在执行 select 语句的时候需要给操作对象（表或者一些记录）加上共享锁，但加锁之前需要检查是否有排他锁(X锁)，如果没有，则可以加共享锁（一个对象上可以加 n 个共享锁），否则不行。共享锁通常在执行完 select 语句之后被释放，当然也有可能是在事务结束（包括正常结束和异常结束）的时候被释放，主要取决与数据库所设置的事务隔离级别。 排它(X)锁(也叫写锁)：仅允许一个事务封锁此页；其他任何事务必须等到 X 锁被释放才能对该页进行访问；X 锁一直到事务结束才能被释放。执行 insert、update、delete 语句的时候需要给操作的对象加排他锁，在加排他锁之前必须确认该对象上没有其他任何锁，一旦加上排他锁之后，就不能再给这个对象加其他任何锁。排他锁的释放通常是在事务结束的时候（当然也有例外，就是在数据库事务隔离级别被设置成 Read Uncommitted（读未提交数据）的时候，这种情况下排他锁会在执行完更新操作之后就释放，而不是在事务结束的时候）。 (2)按照锁的粒度 所谓粒度，即细化的程度。锁的粒度越大，则并发性越低且开销大；锁的粒度越小，则并发性高且开销小。 行级锁 仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 InnoDB 存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用行级锁。(按照锁的类型，2个标准。) 页级锁 一次锁定相邻的一组记录。特点开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 表级锁 直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许。特点：开销小，加锁快；不会出现死锁；锁定粒度最大，发生锁冲突的概率最高，并发度最低。 有 2 种模式：表共享读锁和表独占写锁。加读锁的命令:lock table 表名 read;去掉锁的命令：unlock tables。 MyISAM 存储引擎采用的是表级锁。 锁实现：悲观锁和乐观锁悲观锁 锁如其名，他对世界是悲观的，他认为别人访问正在改变的数据的概率是很高的，所以从数据开始更改时就将数据锁住，直到更改完成才释放。 特点：悲观锁可能会造成加锁的时间很长，并发性不好，特别是长事务，影响系统的整体性能。 悲观锁实现方式：数据库提供的锁机制。 １.共享锁: 阻止其他事务写表（即其他事务不能write，可以read） 1select * from table lock in share mode ２.排它锁： 阻止其他事务读、写该表(数据库默认加排它锁) 1select * from table for update ##＃ 乐观锁 乐观锁，他对世界比较乐观，认为别人访问正在改变的数据的概率是很低的，所以直到修改完成准备提交所做的修改到数据库的时候才会将数据锁住，当你读取以及改变该对象时并不加锁，完成更改后释放。乐观锁不能解决脏读的问题。 特点：乐观锁加锁的时间要比悲观锁短，大大提升了大并发量下的系统整体性能表现。 乐观锁实现方式: １.大多是基于数据版本（Version）记录机制实现，需要为每一行数据增加一个版本标识（也就是每一行数据多一个字段 version），每次更新数据都要更新对应的版本号+1。 ２.使用时间戳来实现。同样是在需要乐观锁控制的 table 中增加一个字段，名称无所谓，字段类型使用时间戳 （timestamp）, 和上面的 version 类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则 OK，否则就是版本冲突。 解决更新丢失的方法 加乐观锁或者悲观锁。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中创建对象的5种不同的方式]]></title>
    <url>%2F2018%2F11%2F11%2FJava%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[本文译自：Dzone 作为Java开发者，我们每天都会创建大量的对象，但是，我们总是使用管理依赖系统(如Spring框架)来创建这些对象。其实还有其他方法可以创建对象，在接下来的文章中我会进行详细介绍。 创建对象的5种不同的方式(1)使用new关键字 这是最常见的创建对象的方法，并且也非常简单。通过使用这种方法我们可以调用任何我们需要调用的构造函数。 1Employee emp1 = new Employee(); 123NEW org/programming/mitra/exercises/EmployeeDUPINVOKESPECIAL org/programming/mitra/exercises/Employee.&lt;init&gt; ()V (2)使用class类的newInstance方法 我们也可以使用class类的newInstance()方法来创建对象。此newInstance()方法调用无参构造函数以创建对象。 1Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee").newInstance(); 1234LDC "org.programming.mitra.exercises.Employee"INVOKESTATIC java/lang/Class.forName (Ljava/lang/String;)Ljava/lang/Class;INVOKEVIRTUAL java/lang/Class.newInstance ()Ljava/lang/Object;CHECKCAST org/programming/mitra/exercises/Employee 或者 1Employee emp2 = Employee.class.newInstance(); 123LDC Lorg/programming/mitra/exercises/Employee;.classINVOKEVIRTUAL java/lang/Class.newInstance ()Ljava/lang/Object;CHECKCAST org/programming/mitra/exercises/Employee (3)使用Constructor类的newInstance（）方法 与使用class类的newInstance()方法相似，java.lang.reflect.Constructor类中有一个可以用来创建对象的newInstance()函数方法。通过使用这个newInstance()方法我们也可以调用参数化构造函数和私有构造函数。 12Constructor&lt;Employee&gt; constructor = Employee.class.getConstructor();Employee emp3 = constructor.newInstance(); 123ANEWARRAY java/lang/ObjectINVOKEVIRTUAL java/lang/reflect/Constructor.newInstance ([Ljava/lang/Object;)Ljava/lang/Object;CHECKCAST org/programming/mitra/exercises/Employee newInstance()方法都被称为创建对象的反射方式。事实上，Class类的newInstance()方法内部使用Constructor类的newInstance()方法。这就是为什么后者是首选的，也被不同的框架，如Spring，Hibernate，Struts等使用。 (4)使用clone()方法 实际上无论何时我们调用clone() 方法，JAVA虚拟机都为我们创建了一个新的对象并且复制了之前对象的内容到这个新的对象中。使用 clone()方法创建对象不会调用任何构造函数。要在对象上使用clone()方法，我们需要实现Cloneable接口并在其中定义clone()方法。 1Employee emp4 = (Employee) emp3.clone(); 12INVOKEVIRTUAL org/programming/mitra/exercises/Employee.clone ()Ljava/lang/Object;CHECKCAST org/programming/mitra/exercises/Employee Java克隆是Java社区中最值得探讨的话题，它肯定有它的缺点，但它仍然是创建任何对象的副本的最流行和最简单的方法。 (5)使用反序列化 无论何时我们对一个对象进行序列化和反序列化，JAVA虚拟机都会为我们创建一个单独的对象。在反序列化中，JAVA虚拟机不会使用任何构造函数来创建对象。 对一个对象进行序列化需要我们在类中实现可序列化的接口。 12ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));Employee emp5 = (Employee) in.readObject(); 12INVOKEVIRTUAL java/io/ObjectInputStream.readObject ()Ljava/lang/Object;CHECKCAST org/programming/mitra/exercises/Employee 正如我们在上面的字节码片段中看到的，除了第一个被转换为两个调用：一个是new，另外一个是invokespecial(调用构造函数)，其他4个方法被转换为invokevirtual调用(对象创建直接由这些方法处理)。 示例：准备创建对象的 Employee 类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Employee implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String name; public Employee() &#123; System.out.println("Employee Constructor Called..."); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Employee other = (Employee) obj; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125; @Override public String toString() &#123; return "Employee [name=" + name + "]"; &#125; @Override public Object clone() &#123; Object obj = null; try &#123; obj = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return obj; &#125;&#125; 创建 Employee对象的5种方式 在下面的Java程序中我们用5种方式来创建 Employee对象。您也可以在GitHub上找到源代码 1234567891011121314151617181920212223242526272829303132333435public class ObjectCreation &#123; public static void main(String... args) throws Exception &#123; // By using new keyword Employee emp1 = new Employee(); emp1.setName("Naresh"); System.out.println(emp1 + ", hashcode : " + emp1.hashCode()); // By using Class class's newInstance() method Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee") .newInstance(); // Or we can simply do this // Employee emp2 = Employee.class.newInstance(); emp2.setName("Rishi"); System.out.println(emp2 + ", hashcode : " + emp2.hashCode()); // By using Constructor class's newInstance() method Constructor&lt;Employee&gt; constructor = Employee.class.getConstructor(); Employee emp3 = constructor.newInstance(); emp3.setName("Yogesh"); System.out.println(emp3 + ", hashcode : " + emp3.hashCode()); // By using clone() method Employee emp4 = (Employee) emp3.clone(); emp4.setName("Atul"); System.out.println(emp4 + ", hashcode : " + emp4.hashCode()); // By using Deserialization // Serialization ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("data.obj")); out.writeObject(emp4); out.close(); //Deserialization ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj")); Employee emp5 = (Employee) in.readObject(); in.close(); emp5.setName("Akash"); System.out.println(emp5 + ", hashcode : " + emp5.hashCode()); &#125;&#125; 输出结果12345678Employee Constructor Called...Employee [name=Naresh], hashcode : -1968815046Employee Constructor Called...Employee [name=Rishi], hashcode : 78970652Employee Constructor Called...Employee [name=Yogesh], hashcode : -1641292792Employee [name=Atul], hashcode : 2051657Employee [name=Akash], hashcode : 63313419]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射机制]]></title>
    <url>%2F2018%2F08%2F27%2FJava%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[反射机制反射 当程序无法获知对象类型时，在运行期间动态获取类的所有属性和方法，这种动态获取类信息和动态调用对象方法的功能称为反射机制。 反射机制的实现 Class类与java.lang.reflect类库一起实现反射机制，java.lang.reflect类库包含Field/Method/Constructors类。这些类型的对象由JVM在运行时出创建，分别用于获取未知类的域/方法/构造器：通过Class类和java.lang.reflect类包，未知对象的类信息在运行时被确定，并且在编译时无需获取。 RTTI与java.lang.Class类 RTTI，runtime type information/运行时类型信息，JVM运行时负责记录一个对象的属性。 运行期间，Java通过Class对象记录每个对象的RTTI；每当编写并且编译一个新类时，就会产生一个对应的Class对象（和新类保存在一个同名的.class文件中） JVM通过类加载器创建类的对象实例 类加载器首先检查类的Class对象是否加载，未加载的话从类的.class文件中加载； 一旦类的Class对象被载入内存，它就被用来创建类的所有对象。 java.lang.reflect类 reflect包提供以下类供反射使用，解析目标类。 Class类：代表一个目标类；Field类：代表目标类的成员变量；Method类：代表目标类的方法。Constructor类：代表目标类的构造方法。Array类：提供了动态创建数组，以及访问数组的元素的静态方法； 反射步骤获得目标类的java.lang.Class对象。 1.已获得目标类对象实例，通过目标类对象实例.getClass()返回该类Class对象 12// Object类public final native Class&lt;?&gt; getClass(); ２.已获得目标类名，通过Class c = MyClass.getClass()获得该类Class对象； ３.目标类名在编译器不确定，在运行期确定 如果目标类名在编译器不确定，在运行期可以确定，使用Class.forName(目标类名)获取该类Class对象，要求目标类名必须是全限定；Class.forName(目标类名)内部通过反射API根据目标类名将类手动加载到内存中，称为类加载器加载方法。加载过程中会把目标类的static方法，变量，代码块加载到JVM，注意此时尚未创建对象实例。 利用java.lang.Class对象通过反射API获取目标类信息 １.创建目标类对象实例 Object newInstance()：通过调用默认构造器创建一个对象实例。 ２.获得构造器 1234Constructor[] getConstructors() //获得所有public构造器；Constructor[] getDeclaredConstructors() //获得所有访问权限的构造器Constructor getConstructor(Class[] params) //根据指定参数获得对应构造器；Constructor getDeclaredConstructor(Class[] params) //根据指定参数获得对应构造器； ３.获得变量 1234Field[] getFields() //获得类中所有public变量Field[] getDeclaredFields() //获得类中所有访问权限变量Field getField(String name) //根据变量名得到对应的public变量Field getDeclaredField(String name) //根据变量名获得对应的变量，访问权限不限； 反射的应用 广泛应用于对象序列化和JavaBean中； eclipse等IDE补全机制：eclipse等IDE在代码构建对象时，通过反射机制自动把该对象能使用的方法和属性全部列出来，供用户选择。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
